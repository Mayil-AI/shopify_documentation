Functions
 Overview
 Input and output
 Language support
 Overview
 JavaScript
 Rust
 WebAssembly
 Testing and debugging
 Localization
 Deployment
 Distribution
 Billing
 App Store
 Rust support in Shopify Functions
 You can write your functions in Rust. This guide describes the shopify_function Rust crate that Shopify provides to help developers build with Shopify Functions.
 Requirements
 You need to have graphql_client installed as a dependency in your project:
 Terminal
 $ cargo add graphql_client@0.13.0
 How it works
 The shopify_function Rust crate bundles graphql_client-based type generation, reduces boilerplate code, and makes it easier to test various function inputs. It includes the following components:
 Component Description
 shopify_function_target An attribute macro that transforms the following function to:
 Generate structs and output types for the Function API target from the specified input query and GraphQL schema.
 Export a WebAssembly function with the specified name, which must match the target export in the function extension configuration.
 Automatically handle input parsing from STDIN and output serialization to STDOUT.
 run_function_with_input A utility for unit testing that enables you to add new tests based on a given JSON input string.
 Viewing the generated types
 To preview the types generated by the shopify_function Rust crate, use the cargo doc command.
 Terminal
 $ cargo doc --open
 You can also use the cargo-expand crate to view the generated source, or use the rust-analyzer VSCode extension to get IntelliSense for Rust and the generated types.
 Note
 The generated .output.graphql files are used for output type generation purposes. You can add these files to your .gitignore file.
 Example implementations
 Explore example implementations using the shopify_function Rust crate.
 For API versions 2023-07 and earlier, the generate_types and shopify_function macros can be used directly to conform to previous WebAssembly requirements.
 Rust Shopify Function example
 Explore an example of how to use the shopify_function crate to implement a Shopify Function in Rust.
 Rust Shopify Function example for earlier versions
 Explore an example of how to use the shopify_function crate to implement a Shopify Function in Rust compatible with API versions 2023-07 and earlier.
 Binary size tips
 Shopify Functions compiled Wasm file must be under 256 kB. Here are a few tips to keep binary size small when using Rust:
 Update the shopify_function crate to the latest version.
 For regular expressions, use the regex_lite crate.
 Follow tips & documentation on the johnthagen/min-sized-rust GitHub repository.
 The Functions templates already use many of those tips. Using Rust nightly can help further reduce size with:
 cargo wasi build --release -Z build-std=std,panic_abort -Z build-std-features=panic_immediate_abort
 Use wasm-snip to remove the panicking code, then wasm-opt to strip debug information. For example:
 # Change this line:
 export WASM_PATH=target/wasm32-wasi/release/your-function-name.wasm
 
 RUSTFLAGS="-C strip=none" cargo wasi build --release \
   && wasm-snip --snip-rust-panicking-code $WASM_PATH \
   | wasm-opt -O3 --enable-bulk-memory --strip-debug -o function.no-panic.wasm -
 Bring your own types and deserializers.
 Instead of using the generated structs from the shopify_function_macro crate, write the appropropriate struct definitions and derive the deserializsers using mini_serde.
 The structs from shopify_function_macro can be used as a starting point, see them with cargo expand.
 Alternative serializers are generally less efficient than serde, make sure to benchmark the instruction count when going down this path.
 Next steps
 Explore the reference documentation for the shopify_function Rust crate.
 Was this section helpful?
 YesNo
 ON THIS PAGE
 Requirements
 How it works
 Viewing the generated types
 Example implementations
 Binary size tips
