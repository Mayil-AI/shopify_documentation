APIs
 Collapse sidebar
 Customer Account API
 Unstable
 2024-07 release candidate
 2024-04 latest
 2024-01
 2024-01
 Overview
 Authentication
 Endpoint and queries
 Rate limits
 Status and error codes
 Common objects
 GraphQL Types
 GraphQL Customer Account API
 Create unique customer experiences with the Customer Account API. The API offers a full range of options making it possible for customers to view their orders, manage their profile and much more.
 Authentication
 This guide will provide an overview of the new authentication system for the Customer Account API and help developers understand how to use it effectively.
 Overview
 The Customer Account API is designed to serve as the primary source for customer-scoped data and authenticated customer actions. To ensure secure access to this data, a robust authentication system is in place for developers.
 Authentication process
 We support two types of clients:
 Confidential - A client that is capable of keeping a client secret confidential to the world. This is usually a server-side application.
 Public - A client that is incapable of keeping a client secret confidential to the world. This is usually a client-side application.
 For public clients, we use Proof Key for Code Exchange or PKCE to mitigate the risk of authorization code interception.
 We follow the OAuth 2.0 authorization specification and thus the following steps are required to authenticate and use the Customer Account API.
 Authorization
 Redirect customer to the login page:
 
 GET https://shopify.com/<shop_id>/auth/oauth/authorize
 
 With the following parameters:
 scope
 openid email https://api.customers.com/auth/customer.graphql
 required
 A list of scope names separated by space. Scopes are attached to all access tokens issued from this authorization request and determine what data these access token will be able to retrieve from API endpoints.
 client_id
 <client_id>
 required
 Unique UUID prefixed with shp_ associated with the application, this should be visible in the customer account api settings of the given application / storefront.
 response_type
 code
 required
 Implies that authorization code flow will be used.
 redirect_uri
 <redirect_uri>
 required
 URL to redirect with authorization code after successful authentication. This has to be one of the redirect URIs defined in the customer account api settings of the given application / storefront.
 state
 <state>
 required
 A string of characters which will be returned along with the code during callback/redirect. This is used to prevent CSRF/XSRF. See Generating state for more details on usage.
 nonce
 <nonce>
 This is used to mitigate replay attacks. The nonce will be returned in the id_token as part of the Obtain access code step. See Generating nonce and Retrieving Nonce for more details on usage.
 prompt
 none
 Specifies that no login screen should be shown to the user. If a session is present a code is returned that can be used in the Obtain access token step. If no session is present a login_required error is returned to your redirect_uri endpoint.
 ui_locales
 en
 Specifies the the language for the login screen. Supported Locales: en, fr, cs, da, de, es, fi, it, ja, ko, nb, nl, pl, pt-BR, pt-PT, sv, th, tr, vi, zh-CN, zh-TW
 Public client
 In addition to the parameters above, public clients need to provide the following parameters.
 
 An example implementing a code challenge and verifier can be seen in the Code challenge and verifier section
 code_challenge
 <code_verifier>
 required
 A string that is derived from the code_verifier using a hashing algorithm. The code_verifier is a string that is randomly generated by the client.
 code_challenge_method
 S256
 required
 The code challenge method.
 Authorization Request
 Typescript
 1 const clientId = process.env.CLIENT_ID;
 2 const authorizationRequestUrl = new URL(
 3
    `https://shopify.com/<shop_id>/auth/oauth/authorize`
 4 );
 5
 6 authorizationRequestUrl.searchParams.append(
 7
    'scope',
 8
    'openid email https://api.customers.com/auth/customer.graphql'
 9 );
 10 authorizationRequestUrl.searchParams.append(
 11
    'client_id',
 12
    clientId
 13 );
 14 authorizationRequestUrl.searchParams.append(
 15
    'response_type',
 16
    'code'
 17 );
 18 authorizationRequestUrl.searchParams.append(
 19
    'redirect_uri',
 20
    `<redirect_uri>`
 21 );
 22 authorizationRequestUrl.searchParams.append(
 23
    'state',
 24
    '<state>'
 25 );
 26 authorizationRequestUrl.searchParams.append(
 27
    'nonce',
 28
    '<nonce>'
 29 );
 30
 31 // Public client
 32 const verifier = await generateCodeVerifier();
 33 const challenge = await generateCodeChallenge(verifier);
 34 localStorage.setItem('code-verifier', verifier);
 35
 36 authorizationRequestUrl.searchParams.append(
 37
    'code_challenge',
 38
    challenge
 39 );
 40 authorizationRequestUrl.searchParams.append(
 41
    'code_challenge_method',
 42
    'S256'
 43 );
 44
 45 window.location.href = authorizationRequestUrl.toString()
 Retrieve code to get access token
 When a customer has a successful login and is redirected to the uri specificed in the parameters above, you receive a code as a query parameter. This code will then be used to get an access token which allows you to make requests to the Customer Account API.
 
 The optional state parameter will also be returned if it was part of the original Authorization step above.
 
 Obtain access token
 To authenticate with the Customer Account API, your application needs to obtain an access token. You can request an access token by sending a POST request to the token endpoint with the following parameters:
 
 POST https://shopify.com/<shop_id>/auth/oauth/token
 
 If in the Authorization step a nonce was passed. This is where it can be validated. See Retrieving nonce for more details.
 
 This will return a json result that contains the access_token, refresh_token, id_token and expires_in (in seconds) of the access token.
 
 Confidential client only
 
 Headers containing authorization credentials are required in order to get an access token. Check out the Authorization header section for more details.
 
 If a response code of 400 with a message of invalid_grant is returned, then ensure that padding is removed (for example, =) from your base64-encoded code challenge in the Authorization step. Additionally, make sure to replace “+” with “-” and “/” with “_” to ensure compatibility with URL encoding.
 
 If a response code of 401 with a message of invalid_client is returned, then verify that the client_id is correct.
 
 If a response code of 401 with a message of invalid_token in the www-authenticate header is returned, then ensure that an origin header is specified in the request. Verify that it's set in the list of Javascript Origin(s) in the Customer Account API settings page.
 
 If a response code of 403 with a message of You do not have permission to access this website is returned, then ensure that an user-agent header is specified in the request.
 
 grant_type
 authorization_code
 required
 Must be set to authorization_code.
 client_id
 <client_id>
 required
 Same client_id used in the authorize request.
 code
 <code>
 required
 The code received as a parameter as part of the Retrieve code section.
 redirect_uri
 <redirect_uri>
 required
 Same redirect_uri specified in the first /authorize request.
 Public Client
 In addition to the parameters above, public clients need to provide the following parameters.
 code_verifier
 <code_verifier>
 required
 The code_verifier used to generate the code_challenge in the Authorization section.
 Obtain Access Token
 Typescript
 1 const clientId = process.env.CLIENT_ID;
 2 const body = new URLSearchParams();
 3
 4 body.append('grant_type', 'authorization_code');
 5 body.append('client_id', clientId);
 6 body.append(
 7
    'redirect_uri',
 8
    `<redirect_uri>`,
 9 );
 10 body.append('code', code);
 11
 12 // Public Client
 13 const codeVerifier = localStorage.getItem('code-verifier');
 14 body.append('code_verifier', codeVerifier);
 15
 16 const headers = {
 17
    'content-type': 'application/x-www-form-urlencoded',
 18
    // Confidential Client
 19
    'Authorization': 'Basic `<credentials>`'
 20 }
 21
 22 const response = await fetch(`https://shopify.com/<shop_id>/auth/oauth/token`, {
 23
    method: 'POST',
 24
    headers: headers,
 25
    body,
 26 });
 27
 28 interface AccessTokenResponse {
 29
    access_token: string;
 30
    expires_in: number;
 31
    id_token: string;
 32
    refresh_token: string;
 33 }
 34
 35 const {access_token, expires_in, id_token, refresh_token} =
 36
    await response.json<AccessTokenResponse>();
 Use refresh token
 The access token retrieved in the previous step has an associated expires_in property (in seconds). Once that has passed, the access token is invalid and needs to be refreshed.
 
 The procedure to refresh the token is very similar to the Obtain access token step except different parameters are passed.
 
 POST https://shopify.com/<shop_id>/auth/oauth/token
 
 grant_type
 refresh_token
 required
 Must be set to refresh_token.
 client_id
 <client_id>
 required
 Same client_id used in the authorize request.
 refresh_token
 <refresh_token>
 required
 The refresh_token received as part of the Obtain access token step.
 Refresh Token
 Typescript
 1 const clientId = process.env.CLIENT_ID;
 2 const body = new URLSearchParams();
 3
 4 body.append('grant_type', 'refresh_token');
 5 body.append('client_id', clientId);
 6 body.append('refresh_token', refresh_token);
 7
 8 const headers = {
 9
    'content-type': 'application/x-www-form-urlencoded',
 10
    // Confidential Client
 11
    'Authorization': 'Basic `<credentials>`'
 12 }
 13
 14 const response = await fetch(`https://shopify.com/<shop_id>/auth/oauth/token`, {
 15
    method: 'POST',
 16
    headers: headers,
 17
    body,
 18 });
 19
 20 interface AccessTokenResponse {
 21
    access_token: string;
 22
    expires_in: number;
 23
    id_token: string;
 24
    refresh_token: string;
 25 }
 26
 27 const {access_token, expires_in, id_token, refresh_token} =
 28
    await response.json<AccessTokenResponse>();
 Use Access Token
 We implement Token exchange which means in order to make requests to the Customer Account API you need to exchange the access_token that was received in the Obtain access token section for another access_token.
 
 POST https://shopify.com/<shop_id>/auth/oauth/token
 
 This will return a json result that contains the access_token and expires_in (in seconds) of the access token.
 
 The access_token above will allow access to making requests to the Customer Account API. Please refer to the Endpoint and queries section on usage.
 
 Confidential client only
 
 Headers containing authorization credentials are required in order to get an access token. Check out the Authorization header section for more details.
 
 Authorization: Basic <credentials>
 
 If this request responds with a 404, then check for a malformed URL when doing the fetch request.
 
 grant_type
 urn:ietf:params:oauth:grant-type:token-exchange
 required
 Must be set to urn:ietf:params:oauth:grant-type:token-exchange.
 client_id
 <client_id>
 required
 Same client_id used in the Authorization step.
 audience
 30243aa5-17c1-465a-8493-944bcc4e88aa
 required
 The Customer Account API client ID. Must be set to 30243aa5-17c1-465a-8493-944bcc4e88aa.
 subject_token
 <access_token>
 required
 The access_token received in the Obtain access token section.
 subject_token_type
 urn:ietf:params:oauth:token-type:access_token
 required
 Must be set to urn:ietf:params:oauth:token-type:access_token.
 scopes
 https://api.customers.com/auth/customer.graphql
 required
 The scopes you want to request access to. If not specified, the scopes from the original access token will be used.
 Token Exchange
 Typescript
 1 const clientId = process.env.CLIENT_ID;
 2 const customerApiClientId = '30243aa5-17c1-465a-8493-944bcc4e88aa';
 3 const accessToken = cookie.get('accessToken');
 4 const body = new URLSearchParams();
 5
 6 body.append(
 7
    'grant_type',
 8
    'urn:ietf:params:oauth:grant-type:token-exchange',
 9 );
 10 body.append('client_id', clientId);
 11 body.append('audience', customerApiClientId);
 12 body.append('subject_token', accessToken);
 13 body.append(
 14
    'subject_token_type',
 15
    'urn:ietf:params:oauth:token-type:access_token',
 16 );
 17 body.append('scopes', 'https://api.customers.com/auth/customer.graphql');
 18
 19 const headers = {
 20
    'content-type': 'application/x-www-form-urlencoded',
 21
    // Confidential Client
 22
    'Authorization': 'Basic `<credentials>`'
 23 }
 24
 25 const response = await fetch(`https://shopify.com/<shop_id>/auth/oauth/token`, {
 26
    method: 'POST',
 27
    headers: headers,
 28
    body,
 29 });
 30
 31 interface AccessTokenResponse {
 32
    access_token: string;
 33
    expires_in: number;
 34 }
 35
 36 const {access_token} = await response.json<AccessTokenResponse>();
 Authorization header (confidential client only)
 An Authorization Header is a Base64 encode of the client_id and client_secret and is required for certain requests.
 Authorization Header
 Authorization header
 1 const clientId = process.env.CLIENT_ID;
 2 const clientSecret = process.env.CLIENT_SECRET;
 3
 4 const credentials = btoa(`${clientId}:${clientSecret}`);
 Code challenge and verifier (public client only)
 A code challenge and verifier are needed when doing requests from a public client in order to verify that the client is the same client that initiated the authorization request.
 Code Challenge and Verifier
 Code Challenge and Verifier
 1 export async function generateCodeVerifier() {
 2
    const rando = generateRandomCode();
 3
    return base64UrlEncode(rando);
 4 }
 5
 6 export async function generateCodeChallenge(codeVerifier: string) {
 7
    const digestOp = await crypto.subtle.digest(
 8
      { name: "SHA-256" },
 9
      new TextEncoder().encode(codeVerifier)
 10
    );
 11
    const hash = convertBufferToString(digestOp);
 12
    return base64UrlEncode(hash);
 13 }
 14
 15 function generateRandomCode() {
 16
    const array = new Uint8Array(32);
 17
    crypto.getRandomValues(array);
 18
    return String.fromCharCode.apply(null, Array.from(array));
 19 }
 20
 21 function base64UrlEncode(str: string) {
 22
    const base64 = btoa(str);
 23
    // This is to ensure that the encoding does not have +, /, or = characters in it.
 24
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
 25 }
 26
 27 function convertBufferToString(hash: ArrayBuffer) {
 28
    const uintArray = new Uint8Array(hash);
 29
    const numberArray = Array.from(uintArray);
 30
    return String.fromCharCode(...numberArray);
 31 }
 Generating state
 The state parameter is used to maintain the state of the client application during the Authorization step. It acts as a security measure to prevent cross-site request forgery (CSRF) attacks.
 
 This state is then returned as a parameter in addition to the code in the Retrieve code to get access token and can be used to verify that the response matches the request.
 
 Generating State
 State
 1 export async function generateState(): Promise<string> {
 2
    const timestamp = Date.now().toString();
 3
    const randomString = Math.random().toString(36).substring(2);
 4
    return timestamp + randomString;
 5 }
 Generating nonce
 A nonce (number used once) is a random or unique value used in to prevent replay attacks. It can be provided in the Authorization step to ensure the freshness and integrity of the communication.
 
 Nonces help protect against unauthorized reuse of captured messages by verifying that they are recent and have not been tampered with.
 
 Once passed as part of the Authorization step, it can be verified in the Obtain access token step. See Retrieving nonce for more information.
 Generating Nonce
 Nonce
 1 export async function generateNonce(length: number) {
 2
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
 3
    let nonce = '';
 4
 5
    for (let i = 0; i < length; i++) {
 6
      const randomIndex = Math.floor(Math.random() * characters.length);
 7
      nonce += characters.charAt(randomIndex);
 8
    }
 9
 10
    return nonce;
 11 }
 Retrieving nonce
 In the Obtain access token step an id_token is returned, this is an encoded JWT token that once decoded contains the nonce that was passed in the Authorization step.
 
 Retrieving Nonce
 Retrieving Nonce
 1 export async function getNonce(token: string) {
 2
    return decodeJwt(token).payload.nonce;
 3 }
 4
 5 export function decodeJwt(token: string) {
 6
    const [header, payload, signature] = token.split('.');
 7
 8
    const decodedHeader = JSON.parse(atob(header));
 9
    const decodedPayload = JSON.parse(atob(payload));
 10
 11
    return {
 12
      header: decodedHeader,
 13
      payload: decodedPayload,
 14
      signature,
 15
    };
 16 }
 Logging out
 To log out a customer, you need to redirect them to the logout endpoint with the following parameters:
 GET https://shopify.com/<shop_id>/auth/logout
 id_token_hint
 <id_token>
 required
 The id_token received as part of the authentication process in the Use access token section.
 post_logout_redirect_uri
 <post_logout_redirect_uri>
 The URI to redirect to after logging out. If this isn't specified, then it defaults to one of the URIs in the Logout URI setting.
 Stay authenticated from Headless storefront to Checkout
 New Customer Accounts must be enabled.
 
 In order to stay authenticated from the headless storefront to checkout, you need to add a query parameter logged_in=true to the end of the checkout url.
 
 If the checkout url is https://<shop-domain>/checkouts/<checkout_id> then adding the parameter will result in the URL looking like:
 
 https://<shop-domain>/checkouts/<checkout_id>?logged_in=true
 Stay authenticated from Checkout to Headless storefront via Cart
 A customer can be authenticated in checkout but not in the headless storefront, to tackle this situation see the following procedure.
 
 If a customer navigates back to the cart via the cart breadcrumb, a logged_in=true query parameter is passed along with the URL. This can be used to help make the decision to use the procedure below to avoid re-authenticating a customer to the headless storefront.
 
 Follow the same procedure described in the Authentication step to redirect the customer but include the optional prompt parameter with a value of none. This will not prompt the customer to log in again if they are already logged in.
 
 A code will be passed to the redirect_uri that you specified and from there the steps above to query the Customer Account API are the same.
 
 If for some reason the customer's session has expired, the redirect_uri will receive an error response with the error parameter set to login_required.
 
 Endpoint and queries
 The Customer Account API is available only in GraphQL.
 All Customer Account API queries are made on a single GraphQL endpoint, which only accepts POST requests:
 POST
 https://shopify.com/<shop_id>/account/customer/api/unstable/graphql
 The Customer Account API is versioned, with new releases four times a year. To keep your app stable, make sure that you specify a supported version in the URL.
 
 If this request responds with a 500, then verify you don't have any misspelled parameters when obtaining the access token.
 
 POST
 https://shopify.com/<shop_id>/account/customer/api/unstable/graphql
 Node.js
 curl
 1
 2
 3
 4
 15
 const response = await fetch(
 'https://shopify.com/<shop-id>/account/customer/api/unstable/graphql',
 {
 method: 'POST',
 headers: {
 'Content-Type': 'application/json',
 Authorization: {access_token},
 },
 body: JSON.stringify({
 operationName: 'SomeQuery',
 'query { personalAccount { email }}',
 variables: {},
 }),
 },
 Rate limits
 The Customer Account API is rate-limited using calculated query costs, measured in cost points. Each field returned by a query costs a set number of points. The total cost of a query is the sum of all the fields it returns, so more complex queries cost more to run.
 This API limits each app to 7500 cost points per store and customer. This quota replenishes at a rate of either 100.0 or 200.0 cost points per second, depending on your plan.
 Most fields cost 1 points. Most mutations cost 10 points. The best way to determine the true cost of a query is to run it. The API response includes information about the total query cost and the client's current quota under the extensions key. Include an 'X-GraphQL-Cost-Include-Fields': true header to receive a more detailed breakdown of the query cost.
 Learn more about rate limits.
 {}
 Request
 1 {
 2
    personalAccount {
 3
      firstName
 4
      lastName
 5
    }
 6 }
 {}
 Response
 JSON
 1 {
 2
    "errors": [
 3
      {
 4
        "message": "Throttled",
 5
        "extensions": {
 6
          "code": "THROTTLED",
 7
          "documentation": "https://shopify.dev/api/usage/rate-limits"
 8
        }
 9
      }
 10
    ]
 11 }
 Status and error codes
 All API queries return HTTP status codes that contain more information about the response.
 200 OK
 GraphQL HTTP status codes are different from REST API status codes. Most importantly, the GraphQL API can return a 200 OK response code in cases that would typically produce 4xx or 5xx errors in REST.
 Error handling
 The response for the errors object contains additional detail to help you debug your operation.
 The response for mutations contains additional detail to help debug your query. To access this, you must request userErrors.
 Properties
 errors
 array
 A list of all errors returned
 Show error item properties
 {}
 Sample 200 error responses
 Throttled
 Internal
 1 {
 2
    "errors": [
 3
      {
 4
        "message": "Throttled",
 5
        "extensions": {
 6
          "code": "THROTTLED",
 7
          "documentation": "https://shopify.dev/api/usage/rate-limits"
 8
        }
 9
      }
 10
    ]
 11 }
 4xx and 5xx status codes
 The 4xx and 5xx errors occur infrequently. They are often related to network communications, your account, or an issue with Shopify’s services.
 Many errors that would typically return a 4xx or 5xx status code, return an HTTP 200 errors response instead. Refer to the 200 OK section above for details.
 400 Bad Request
 The server will not process the request.
 401 Unauthorized
 The client does not have correct authentication credentials.
 402 Payment Required
 The shop is frozen. The shop owner will need to pay the outstanding balance to unfreeze the shop.
 403 Forbidden
 The shop is forbidden. Returned if the store has been marked as fraudulent.
 404 Not Found
 The resource isn’t available. This is often caused by querying for something that’s been deleted.
 423 Locked
 The shop isn’t available. This can happen when stores repeatedly exceed API rate limits or due to fraud risk.
 5xx Errors
 An internal error occurred in Shopify. Check out the Shopify status page for more information.
 Didn’t find the status code you’re looking for? View the complete list of API status response and error codes.
 {}
 Sample error codes
 400
 402
 401
 404
 423
 500
 1 HTTP/1.1 400 Bad Request
 2 {
 3
    "errors": {
 4
      "query": "Required parameter missing or invalid"
 5
    }
 6 }
 Updates & News
 Developer changelog
 Partner blog
 Engineering blog
